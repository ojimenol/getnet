package {{invokerPackage}};

import com.fasterxml.jackson.annotation.JsonInclude;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.InvalidMediaTypeException;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.springframework.http.RequestEntity.BodyBuilder;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.http.codec.json.JacksonJsonDecoder;
import org.springframework.http.codec.json.JacksonJsonEncoder;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StringUtils;
import org.springframework.http.client.reactive.ClientHttpRequest;
import org.springframework.web.client.RestClientException;
import org.springframework.web.util.UriComponentsBuilder;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClient.ResponseSpec;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.BodyInserter;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;
import reactor.util.function.Tuple3;
import reactor.util.function.Tuples;
import reactor.util.retry.Retry;
import tools.jackson.core.json.JsonReadFeature;
import tools.jackson.databind.json.JsonMapper;

import java.text.DateFormat;
import java.text.ParseException;
import java.time.Duration;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import {{javaxPackage}}.annotation.Nullable;

{{#jsr310}}
import java.time.OffsetDateTime;
{{/jsr310}}

import com.santander.getnet.api.ExternalClientApi;
import {{invokerPackage}}.auth.Authentication;
import {{invokerPackage}}.auth.HttpBasicAuth;
import {{invokerPackage}}.auth.HttpBearerAuth;
import {{invokerPackage}}.auth.ApiKeyAuth;
{{#hasOAuthMethods}}
import {{invokerPackage}}.auth.OAuth;
{{/hasOAuthMethods}}

{{>generatedAnnotation}}
public class ApiClient{{#jsr310}} extends JavaTimeFormatter{{/jsr310}} implements ExternalClientApi {
    private static final Logger LOG = LoggerFactory.getLogger(ApiClient.class);
    private static final String URI_TEMPLATE_ATTRIBUTE = WebClient.class.getName() + ".uriTemplate";

    private final HttpHeaders defaultHeaders;
    private final MultiValueMap<String, String> defaultCookies;
    private String basePath;
    private int retries;
    private int retrySeconds;
    private WebClient webClient;
    private final DateFormat dateFormat;
    private final JsonMapper jsonMapper;
    private Map<String, Authentication> authentications;

    public ApiClient() {
        this.defaultHeaders = new HttpHeaders();
        this.defaultCookies = new LinkedMultiValueMap<>();
        this.basePath = "{{basePath}}";
        this.retries = 0;
        this.retrySeconds = 0;
        this.dateFormat = createDefaultDateFormat();
        this.jsonMapper = createDefaultJsonMapper(this.dateFormat);
        this.webClient = buildWebClient(this.jsonMapper);
        this.init();
    }

    public ApiClient(WebClient webClient) {
        this(Optional.ofNullable(webClient).orElseGet(() -> buildWebClient()), createDefaultDateFormat());
    }

    public ApiClient(JsonMapper mapper, DateFormat format) {
        this(buildWebClient(mapper.rebuild().build()), format);
    }

    public ApiClient(WebClient webClient, JsonMapper mapper, DateFormat format) {
        this(Optional.ofNullable(webClient)
                .orElseGet(() -> buildWebClient(mapper.rebuild().build())), format);
    }

    private ApiClient(WebClient webClient, DateFormat format) {
        this.defaultHeaders = new HttpHeaders();
        this.defaultCookies = new LinkedMultiValueMap<>();
        this.basePath = "{{basePath}}";
        this.retries = 0;
        this.retrySeconds = 0;
        this.webClient = webClient;
        this.dateFormat = format;
        this.jsonMapper = createDefaultJsonMapper(format);
        this.init();
    }

    public static DateFormat createDefaultDateFormat() {
        DateFormat dateFormat = new RFC3339DateFormat();
        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
        return dateFormat;
    }

    public static JsonMapper createDefaultJsonMapper(@Nullable DateFormat dateFormat) {
        if (null == dateFormat) {
            dateFormat = createDefaultDateFormat();
        }

        return JsonMapper.builder()
                .configure(JsonReadFeature.ALLOW_MISSING_VALUES, true)
                .configure(JsonReadFeature.ALLOW_SINGLE_QUOTES, true)
                .defaultDateFormat(dateFormat)
                .changeDefaultPropertyInclusion(incl -> incl.withContentInclusion(JsonInclude.Include.NON_NULL))
                .findAndAddModules()
                .build();
    }

    protected void init() {
        // Setup authentications (key: authentication name, value: authentication).
        Map<String, Authentication> auths = new HashMap<>();{{#authMethods}}{{#isBasic}}{{#isBasicBasic}}
        auths.put("{{name}}", new HttpBasicAuth());{{/isBasicBasic}}{{#isBasicBearer}}
        auths.put("{{name}}", new HttpBearerAuth("{{scheme}}"));{{/isBasicBearer}}{{/isBasic}}{{#isApiKey}}
        auths.put("{{name}}", new ApiKeyAuth({{#isKeyInHeader}}"header"{{/isKeyInHeader}}{{#isKeyInQuery}}"query"{{/isKeyInQuery}}{{#isKeyInCookie}}"cookie"{{/isKeyInCookie}}, "{{keyParamName}}"));{{/isApiKey}}{{#isOAuth}}
        auths.put("{{name}}", new OAuth());{{/isOAuth}}{{/authMethods}}
        // Prevent the authentications from being modified.
        this.authentications = Collections.unmodifiableMap(auths);
    }

    /**
    * Build the WebClientBuilder used to make WebClient.
    * @param mapper JsonMapper used for serialize/deserialize
    * @return WebClient
    */
    public static WebClient.Builder buildWebClientBuilder(JsonMapper mapper) {
        ExchangeStrategies strategies = ExchangeStrategies.builder().codecs((clientDefaultCodecsConfigurer) -> {
            clientDefaultCodecsConfigurer.defaultCodecs().jackson2JsonEncoder(new JacksonJsonEncoder(mapper, MediaType.APPLICATION_JSON));
            clientDefaultCodecsConfigurer.defaultCodecs().jackson2JsonDecoder(new JacksonJsonDecoder(mapper, MediaType.APPLICATION_JSON));
        }).build();
        return WebClient.builder().exchangeStrategies(strategies);
    }

    /**
     * Build the WebClientBuilder used to make WebClient.
     * @return WebClient
     */
    public static WebClient.Builder buildWebClientBuilder() {
        return buildWebClientBuilder(createDefaultJsonMapper(null));
    }

    /**
     * Build the WebClient used to make HTTP requests.
     * @param mapper JsonMapper used for serialize/deserialize
     * @return WebClient
     */
    public static WebClient buildWebClient(JsonMapper mapper) {
        return buildWebClientBuilder(mapper).build();
    }

    /**
     * Build the WebClient used to make HTTP requests.
     * @return WebClient
     */
    public static WebClient buildWebClient() {
        return buildWebClientBuilder(createDefaultJsonMapper(null)).build();
    }

    /**
     * Get the current base path
     * @return String the base path
     */
    public String getBasePath() {
        return this.basePath;
    }

    /**
     * Set the base path, which should include the host
     * @param basePath the base path
     * @return ApiClient this client
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    /**
    * Get the retries
    * @return String the base path
    */
    public int getRetries() {
    return this.retries;
    }

    /**
    * Set the retries,
    * @param numRetries the num retries
    * @return ApiClient this client
    */
    public ApiClient setRetries(int numRetries) {
    this.retries = numRetries;
    return this;
    }

    /**
    * Get the seconds between retries
    * @return int seconds
    */
    public int getRetrySeconds() {
    return this.retrySeconds;
    }

    /**
    * Set seconds between retrys
    * @param seconds
    * @return ApiClient this client
    */
    public ApiClient setRetrySeconds(int seconds) {
    this.retrySeconds = seconds;
    return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     * @return Map the currently configured authentication types
     */
    public Map<String, Authentication> getAuthentications() {
        return this.authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return this.authentications.get(authName);
    }

    /**
     * Helper method to set access token for the first Bearer authentication.
     * @param bearerToken Bearer token
     */
    public void setBearerToken(String bearerToken) {
        getAuthenticationObject(HttpBearerAuth.class, "No Bearer authentication configured!")
            .setBearerToken(bearerToken);
    }

    /**
     * Helper method to set username for the first HTTP basic authentication.
     * @param username the username
     */
    public void setUsername(String username) {
        getAuthenticationObject(HttpBasicAuth.class, "No HTTP basic authentication configured!")
            .setUsername(username);
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     * @param password the password
     */
    public void setPassword(String password) {
        getAuthenticationObject(HttpBasicAuth.class, "No HTTP basic authentication configured!")
            .setPassword(password);
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     * @param apiKey the API key
     */
    public void setApiKey(String apiKey) {
        getAuthenticationObject(ApiKeyAuth.class, "No API key authentication configured!")
            .setApiKey(apiKey);
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     * @param apiKeyPrefix the API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        getAuthenticationObject(ApiKeyAuth.class, "No API key authentication configured!")
            .setApiKeyPrefix(apiKeyPrefix);
    }

    {{#hasOAuthMethods}}
    /**
     * Helper method to set access token for the first OAuth2 authentication.
     * @param accessToken the access token
     */
    public void setAccessToken(String accessToken) {
        getAuthenticationObject(OAuth.class, "No OAuth2 authentication configured!")
            .setAccessToken(accessToken);
    }

    {{/hasOAuthMethods}}
    /**
     * Set the User-Agent header's value (by adding to the default header map).
     * @param userAgent the user agent string
     * @return ApiClient this client
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param name The header's name
     * @param value The header's value
     * @return ApiClient this client
     */
    public ApiClient addDefaultHeader(String name, String value) {
        if (this.defaultHeaders.containsHeader(name)) {
            this.defaultHeaders.remove(name);
        }
        this.defaultHeaders.add(name, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param name The cookie's name
     * @param value The cookie's value
     * @return ApiClient this client
     */
    public ApiClient addDefaultCookie(String name, String value) {
        if (this.defaultCookies.containsKey(name)) {
            this.defaultCookies.remove(name);
        }
        this.defaultCookies.add(name, value);
        return this;
    }

    /**
     * Get the date format used to parse/format date parameters.
     * @return DateFormat format
     */
    public DateFormat getDateFormat() {
        return this.dateFormat;
    }

    /**
     * Parse the given string into Date object.
     */
    public Date parseDate(String str) {
        try {
            return this.dateFormat.parse(str);
        } catch (ParseException pe) {
            throw new RuntimeException(pe);
        }
    }

    /**
     * Format the given Date object into string.
     */
    public String formatDate(Date date) {
        return this.dateFormat.format(date);
    }

    /**
     * Get the ObjectMapper used to make HTTP requests.
     * @return ObjectMapper objectMapper
     */
    public JsonMapper getJsonMapper() {
        return this.jsonMapper;
    }

    /**
     * Get the WebClient used to make HTTP requests.
     * @return WebClient webClient
     */
    public WebClient getWebClient() {
        return this.webClient;
    }

    /**
     * Set the WebClient used to make HTTP requests.
     * @param client webClient
     */
    public void setWebClient(WebClient client) {
        this.webClient = client;
    }

    /**
     * Format the given parameter object into string.
     * @param param the object to convert
     * @return String the parameter represented as a String
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date) {
            return this.formatDate( (Date) param);
        } {{#jsr310}}else if (param instanceof OffsetDateTime) {
            return this.formatOffsetDateTime((OffsetDateTime) param);
        } {{/jsr310}}else if (param instanceof Collection) {
            return String.join(",", ((Collection<?>) param).stream().map(String::valueOf).toList());
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Converts a parameter to a {@link MultiValueMap} for use in REST requests
     * @param collectionFormat The format to convert to
     * @param name The name of the parameter
     * @param value The parameter's value
     * @return a Map containing the String value(s) of the input parameter
     */
    @SuppressWarnings("unchecked")
    public MultiValueMap<String, String> parameterToMultiValueMap(CollectionFormat collectionFormat, String name, Object value) {
        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();

        if (Objects.nonNull(name) && !name.isEmpty() && Objects.nonNull(value)) {
            if (Objects.isNull(collectionFormat)) {
                collectionFormat = CollectionFormat.CSV;
            }

            if (value instanceof Map) {
                final var map = ((Map<String, Object>)value);
                map.keySet()
                    .forEach(key -> params.add(key, this.parameterToString(map.get(key))));
                return params;
            } else {
                if (!(value instanceof Collection)) {
                    params.add(name, this.parameterToString(value));
                    return params;
                } else {
                    var valueCollection = (Collection)value;
                    if (valueCollection.isEmpty()) {
                        return params;
                    } else if (collectionFormat.equals(CollectionFormat.MULTI)) {
                        valueCollection
                            .forEach(val -> params.add(name, this.parameterToString(val)));
                        return params;
                    } else {
                        Optional.of(valueCollection)
                            .map(col -> col.stream().toList())
                            .map(collectionFormat::collectionToString)
                            .ifPresent(valueString -> params.add(name, valueString));
                        return params;
                    }
                }
            }
        } else {
            return params;
        }
    }

    /**
    * Check if the given {@code String} is a JSON MIME.
    * @param mediaType the input MediaType
    * @return boolean true if the MediaType represents JSON, false otherwise
    */
    public boolean isJsonMime(String mediaType) {
        // "* / *" is default to JSON
        if ("*/*".equals(mediaType)) {
            return true;
        } else {
            try {
                return this.isJsonMime(MediaType.parseMediaType(mediaType));
            } catch (InvalidMediaTypeException e) {
                return false;
            }
        }
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *     application/json
     *     application/json; charset=UTF8
     *     APPLICATION/JSON
     * @param mediaType the input MediaType
     * @return boolean true if the MediaType represents JSON, false otherwise
     */
    public boolean isJsonMime(MediaType mediaType) {
        return Objects.nonNull(mediaType)
            && (MediaType.APPLICATION_JSON.isCompatibleWith(mediaType)
                || mediaType.getSubtype().matches("^.*(\\+json|ndjson)[;]?\\s*$"));
    }

    /**
    * Check if the given {@code String} is a Problem JSON MIME (RFC-7807).
    * @param mediaType the input MediaType
    * @return boolean true if the MediaType represents Problem JSON, false otherwise
    */
    public boolean isProblemJsonMime(String mediaType) {
        return "application/problem+json".equalsIgnoreCase(mediaType);
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *     if JSON exists in the given array, use it;
     *     otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return List The list of MediaTypes to use for the Accept header
     */
    public List<MediaType> selectHeaderAccept(String[] accepts) {
        if (accepts.length > 0) {
            return Stream.of(accepts)
                .filter(accept -> this.isJsonMime(MediaType.parseMediaType(accept)) && !this.isProblemJsonMime(accept))
                .findFirst()
                .map(accept -> Collections.singletonList(MediaType.parseMediaType(accept)))
                .orElseGet(() -> MediaType.parseMediaTypes(StringUtils.arrayToCommaDelimitedString(accepts)));
        } else {
            return null;
        }
    }

    /**
     * Select the Content-Type header's value from the given array:
     *     if JSON exists in the given array, use it;
     *     otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return MediaType The Content-Type header to use. If the given array is empty, null will be returned.
     */
    public MediaType selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length > 0) {
            return Stream.of(contentTypes)
                .map(MediaType::parseMediaType)
                .filter(this::isJsonMime)
                .findFirst()
                .orElseGet(() -> MediaType.parseMediaType(contentTypes[0]));
        } else {
            return null;
        }
    }

    /**
     * Select the body to use for the request
     * @param obj the body object
     * @param formParams the form parameters
     * @param contentType the content type of the request
     * @return Object the selected body
     */
    protected BodyInserter<?, ? super ClientHttpRequest> selectBody(Object obj, MultiValueMap<String, Object> formParams, MediaType contentType) {
        if(MediaType.APPLICATION_FORM_URLENCODED.equals(contentType)) {
            var newMap = formParams.entrySet().stream()
                .collect(Collectors.toMap(Map.Entry::getKey, entry -> List.of(String.valueOf(entry.getValue()))));
            return BodyInserters.fromFormData(MultiValueMap.fromMultiValue(newMap));
        } else if (MediaType.MULTIPART_FORM_DATA.equals(contentType)) {
            return BodyInserters.fromMultipartData(formParams);
        } else {
            return obj != null ? BodyInserters.fromValue(obj) : null;
        }
    }

    /**
     * Invoke API by sending HTTP request with the given options.
     *
     * @param <T> the return type to use
     * @param path The sub-path of the HTTP URL
     * @param method The request method
     * @param pathParams The path parameters
     * @param queryParams The query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param formParams The form parameters
     * @param accept The request's Accept header
     * @param contentType The request's Content-Type header
     * @param authNames The authentications to apply
     * @param returnType The return type into which to deserialize the response
     * @return The response body in chosen type
     */
    public ResponseSpec invokeAPI(
            String path, HttpMethod method, Map<String, Object> pathParams,
            MultiValueMap<String, String> queryParams, Object body, HttpHeaders headerParams,
            MultiValueMap<String, String> cookieParams, MultiValueMap<String, Object> formParams,
            List<MediaType> accept, MediaType contentType, String[] authNames)
        throws RestClientException {

        return this.prepareRequest(path, method, pathParams, queryParams, body,
                headerParams, cookieParams, formParams, accept, contentType, authNames)
            .retrieve();
    }

    /**
     * Include queryParams in uriParams taking into account the paramName
     * @param queryParams The query parameters
     * @param uriParams The path parameters
     * return templatized query string
     */
    private String generateQueryUri(MultiValueMap<String, String> queryParams, Map<String, Object> uriParams) {
        Function<String, List<Tuple3<String, String, String>>> flattenMap = name -> Optional.of(name)
            .map(queryParams::get)
            .filter(Predicate.not(Collection::isEmpty))
            .map(values -> IntStream.range(0, values.size())
            .boxed()
            .map(idx -> Tuples.of(name, name + idx, values.get(idx)))
            .toList())
            .orElseGet(() -> List.of(Tuples.of(name, name, "")));

        Function<Tuple3<String, String, String>, String> toQueryParam = data -> {
            if (!data.getT1().equals(data.getT2())) {
                uriParams.put(data.getT2(), data.getT3());
                return data.getT1() + "={" + data.getT2() + "}";
            } else {
                return data.getT1();
            }
        };

        return queryParams.keySet().stream()
            .map(flattenMap)
            .flatMap(List::stream)
            .map(toQueryParam)
            .collect(Collectors.joining("&"));
    }

    private WebClient.RequestBodySpec prepareRequest(String path, HttpMethod method, Map<String, Object> pathParams,
        MultiValueMap<String, String> queryParams, Object body, HttpHeaders headerParams,
        MultiValueMap<String, String> cookieParams, MultiValueMap<String, Object> formParams, List<MediaType> accept,
        MediaType contentType, String[] authNames) {

        this.updateParamsForAuth(authNames, queryParams, headerParams, cookieParams);

        Map<String, Object> uriParams = new HashMap<>(pathParams);

        UnaryOperator<String> finalizeUriBuild = uri -> Optional.of(uri)
            .filter(value -> Objects.nonNull(queryParams) && !queryParams.isEmpty())
            .map(value -> value + "?" + this.generateQueryUri(queryParams, uriParams))
            .orElse(uri);

        var requestBuilder = Optional.of(path)
        .map(UriComponentsBuilder.fromUriString(this.basePath)::path)
        .map(builder -> builder.build(false).toUriString())
        .map(finalizeUriBuild)
        .map(uri -> this.webClient.method(method).uri(uri, uriParams))
        .orElseThrow(RuntimeException::new);

        if (Objects.nonNull(accept)) {
            requestBuilder.accept(accept.toArray(MediaType[]::new));
        }

        if (Objects.nonNull(contentType)) {
            requestBuilder.contentType(contentType);
        }

        this.addHeadersToRequest(headerParams, requestBuilder);
        this.addHeadersToRequest(defaultHeaders, requestBuilder);
        this.addCookiesToRequest(cookieParams, requestBuilder);
        this.addCookiesToRequest(defaultCookies, requestBuilder);

        requestBuilder.attribute(URI_TEMPLATE_ATTRIBUTE, path);
        requestBuilder.body(selectBody(body, formParams, contentType));

        return requestBuilder;
    }

    private <T> T getAuthenticationObject(Class<T> authClass, String errorMessage) {
        return this.authentications.values().stream()
            .filter(authClass::isInstance)
            .findFirst()
            .map(authClass::cast)
            .orElseThrow(() -> new RuntimeException(errorMessage));
    }

    /**
     * Add headers to the request that is being built
     * @param headers The headers to add
     * @param requestBuilder The current request
     */
    protected void addHeadersToRequest(HttpHeaders headers, WebClient.RequestBodySpec requestBuilder) {
        headers.headerSet()
            .forEach(header ->
                requestBuilder.header(header.getKey(), header.getValue().toArray(String[]::new)));
    }

    /**
     * Add cookies to the request that is being built
     * @param cookies The cookies to add
     * @param requestBuilder The current request
     */
    protected void addCookiesToRequest(MultiValueMap<String, String> cookies, WebClient.RequestBodySpec requestBuilder) {
        cookies.forEach((name, values) ->
            requestBuilder.cookie(name, values.stream().findFirst().orElse("")));
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams The query parameters
     * @param headerParams The header parameters
     * @param cookieParams the cookie parameters
     */
    protected void updateParamsForAuth(String[] authNames, MultiValueMap<String, String> queryParams, HttpHeaders headerParams, MultiValueMap<String, String> cookieParams) {
        UnaryOperator<String> checkAuthenticationExists = name -> Optional.of(name)
            .filter(this.authentications::containsKey)
            .orElseThrow(() -> new RestClientException("Authentication undefined: " + name));

        Stream.of(authNames)
            .map(checkAuthenticationExists)
            .map(this.authentications::get)
            .forEach(auth -> auth.applyToParams(queryParams, headerParams, cookieParams));
    }

    /**
    * Formats the specified collection path parameter to a string value.
    *
    * @param collectionFormat The collection format of the parameter.
    * @param values The values of the parameter.
    * @return String representation of the parameter
    */
    public String collectionPathParameterToString(CollectionFormat collectionFormat, Collection<?> values) {
        final var collFormat = Objects.isNull(collectionFormat) ? CollectionFormat.CSV : collectionFormat;

        return Optional.of(collFormat)
            .filter(CollectionFormat.MULTI::equals)
            .map(format -> this.parameterToString(values))
            .orElseGet(() -> collFormat.collectionToString(values));
    }

    public Retry getRetryConfig(String apiName, String operationId, String url) {
        return Retry.backoff(this.getRetries(), Duration.ofSeconds(this.getRetrySeconds()))
            .doBeforeRetry(signal ->
                LOG.info("Error getting data from : {} - {} - {}. Trying to get data again", apiName, operationId, url))
            .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) ->
                new RuntimeException(apiName + " Service failed to process after max retries"));
    }

    public static enum CollectionFormat {
        CSV(","),
        TSV("\t"),
        SSV(" "),
        PIPES("|"),
        MULTI(",");

        private final String separator;

        private CollectionFormat(String separator) {
            this.separator = separator;
        }

        private String collectionToString(Collection<?> collection) {
            return StringUtils.collectionToDelimitedString(collection, this.separator);
        }
    }
}
